<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      background-color: lightblue;
      color: white;
    }
  </style>
</head>
<body>

  <h2>Upload Video</h2>
  <input type="file" id="video" name="video" accept="video/*">
  <button onclick="uploadVideo()">Upload</button>

  <video id="uploadedVideo" width="320" height="240" controls>
    <source id="videoSource">
  </video>

  <p>The model predicted: <span id="predictedObject"></span></p>

  <script>
    let frameIndex = 0;
    const videoElement = document.querySelector('#uploadedVideo');
    const predictedObjectElement = document.querySelector('#predictedObject');

    async function uploadVideo() {
      const fileInput = document.querySelector('#video');
      const formData = new FormData();
      formData.append('file', fileInput.files[0]);

      videoElement.src = URL.createObjectURL(fileInput.files[0]);
      videoElement.load();

      videoElement.onloadeddata = () => {
        videoElement.play();
      }

      videoElement.ontimeupdate = () => {
        if (frameIndex % 10 === 0) {
          predictFrame();
        }
        frameIndex++;
      }
    }

    async function predictFrame() {
      // Here you should extract the current frame from the video and send it to the backend.
      // Note: extracting frames from a video in the browser is a complex task that depends on your specific use case and the capabilities of your backend. 
      // It might involve capturing a screenshot of the video, converting it to a suitable format, and then sending it as a file in a FormData object, similar to how the image is uploaded.

      // Here's a simplified mock implementation for demonstration purposes.
      let frameData = new FormData();
      frameData.append('frame', 'frame data');

      const response = await fetch('ngrokapiurl/results', {
        method: 'POST',
        body: frameData,
      });

      const result = await response.json();

      predictedObjectElement.textContent = result.predicted_object;
    }
  </script>

</body>
</html>
